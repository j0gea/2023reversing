## 3주차 : **STAGE 3** - Computer Science

### Background: Computer Architecture

---

**명령어 집합 구조(ISA):** 컴퓨터의 기본 설계인 컴퓨터 구조 중, *CPU가 사용하는 명령어*에 관련된 설계. **대표적으로 x86-64** 아키텍처가 존재.

**마이크로 아키텍쳐:** *CPU의 하드웨어적 설계.* CPU의 회로를 설계.

**폰 노이만 구조**

—

컴퓨터의 핵심 기능 : 연산, 제어, 저장

- 연산/제어 → CPU
    - 산술/논리 연산 → 산술논리장치
    - CPU 제어 → 제어장치
    - 데이터 저장 → 레지스터(Register)
- 저장 → 기억장치(memory)
    - 주기억장치: 데이터를 **임시**로 저장 → RAM
    - 보조기억장치: 데이터를 **장기간** 저장 → HDD, SSD
- 전자 통로 → bus

**명령어 집합 구조** 

—

Instruction Set Architecture

: CPU가 해석하는 명령어의 집합

다양한 컴퓨팅 환경이 존재하기 때문에 ISA는 다양하다.

- **x68-64 아키텍처(amd64)**

가장 많이 사용되는 ISA

—

64비트 기반 아키텍처

- 64비트: CPU가 한 번에 처리할 수 있는 데이터의 크기. (WORD)
- ALU의 계산 능력, 레지스터의 용량, 버스의 대역폭 등이 영향을 받는다.

1) 레지스터

- 범용 레지스터
    - 임의의 용도로도 사용이 가능한 레지스터
    - rax(함수 반환 값) / rcx(반복 횟수, 연산 시행 횟수) / rsi(데이터 원본 포인터) / rdi(데이터 목적지 포인터) / rsp(스택의 위치 포인터) / rbp(스택 바닥 포인터) …
- 세그먼트 레지스터
    - offset등에 사용되던 비트의 한계로 인해 담을 수 없는 주소의 크기를 늘리기 위한 레지스터.
    - x64 : cs(코드 영역), ds(데이터 영역), ss(스택 메모리 영역), 나머지(운영체제 별로 상이함.
- 명령어 포인터 레지스터
    - rip(실행할 코드의 위치를 가리킴)
- 플래그 레지스터
    - 프로세서의 현재 상태를 저장하고 있는 레지스터
    - CF(Carry Flag, 연산의 결과가 비트의 범위를 넘을 때), ZF(연산의 결과가 0인 경우), SF(연산의 결과가 음수인 경우), OF(Overflow Flag 연산 결과가 비트 범위를 넘을 경우, 부호가 있을 때)

---

### Background: Computer Architecture

---

<aside>
💡 메모리 레이아웃 : 프로세스 가상 메모리의 구성.

</aside>

프로세스에게 할당된 메모리 공간

프로세스 메모리 구조

—

PE 파일(윈도우의 실행 파일)

- PE 헤더 + 1개 이상의 섹션(유사한 용도로 사용되는 데이터가 모여있는 영역)으로 이루어져 있다.

PE 헤더

- 섹션에 대한 정보
- 섹션의 이름/크기/오프셋/속성/권한 등

섹션

- .text : PE의 코드
- .data : PE가 실행중에 참조하는 데이터
- .rdata : 참조하는 상수 및 데이터

.text : 실행 가능한 기계 코드가 위치하는 영역

- 읽기 권한이 부여됨.

.data : 값이 정해져 있는 전역 변수

- 읽기/쓰기 권한이 부여됨

.rdata : 값이 정해진 전역 상수 / 참조할 DLL, 외부 함수들의 정보

- 읽기 권한이 부여됨

섹션이 아닌 메모리

—

- 스택
    - 프로세스의 쓰레드는 자신만의 스택 공간을 가지고 있다.
    - 지역 변수 / 함수의 리턴 주소 저장
    - 읽기/쓰기 권한 부여
- 힙
    - 여러 용도로 사용하기 위해 할당받는 공간. 여러 데이터가 저장될 수 있다.
    - 스택보다 크고 전역적인 접근이 가능함.
    - 실행 중 동적으로 할당되는 공간.
    - 읽기/쓰기/(실행) 권한 부여
